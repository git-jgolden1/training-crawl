<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Training: Crawl Game</title>
    <style>
      * { padding: 0; margin: 0; }
      canvas { background: #eee; display: block; margin: 0 auto; }
    </style>
</head>
<body>

<script>
"use strict";

const canvasProps = {
  xOffset: 3,
  yOffset: 0,
  width: 1000,
  height: 450,
};
document.write('<canvas id="mainCanvas" width="' + canvasProps.width + '" height="' + canvasProps.height + '"></canvas>');
</script>

<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js"></script>
// var myrng = new Math.seedrandom('hello.');
// console.log(myrng());                // Always 0.9282578795792454
// console.log(myrng());                // Always 0.3752569768646784
// 
// // Use "quick" to get only 32 bits of randomness in a float.
// console.log(myrng.quick());          // Always 0.7316977467853576

<script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
<script>

canvas = document.getElementById("mainCanvas");
ctx = canvas.getContext("2d");

const fontStyles = {
  fixed: { name: "Courier", size: 24 },
  compact: { name: "Ariel", size: 18 },
}

// divide into
//   back model : mutable data
//   controller : function + immutable state
//     can access all
//   front model: mutable data
//   view       : function + immutable state
//     can access front model
class Window {

  constructor(name, screen, columnCount, rowCount) {
    this.name = name;
    this.screen = screen;
    this.changed = false;
    this.cellsChanged = [];
    this.columnStart = 0;
    this.rowStart = 0;
    this.columnCount = columnCount;
    this.rowCount = rowCount;
    this.fontStyle = fontStyles.fixed;
  }
  
  toX(c) {
    return (c + this.columnStart) * this.screen.cellWidth + canvasProps.xOffset;
  }

  toY(r) {
    return (r + this.rowStart) * this.screen.cellHeight + canvasProps.yOffset;
  }

  clear() {
    ctx.clearRect(toX(0), toY(0), this.columnCount * this.screen.cellWidth, this.rowCount * this.screen.cellHeight);
  }

  clearCell(windowPos) {
    ctx.clearRect(toX(windowPos.c), toY(windowPos.r), cellWidth, cellHeight);
  }

  drawText(c, r, textToDraw, centerWithin = 0) {
    let xOffset = 0 
    if(centerWithin > 0) {
      let textWidth = ctx.measureText(textToDraw);
      if(textWidth.width < centerWithin) {
        xOffset = Math.floor((centerWithin - textWidth.width) / 2);
      }
    }

    ctx.font = this.fontStyle.size + "px " + this.fontStyle.name;
    ctx.fillText(textToDraw, toX(c) + xOffset, toY(r) + this.fontStyle.size);
  }

  isPosValid(windowPos) {
    return windowPos.c >= 0 
      && windowPos.c < this.columnCount
      && windowPos.r >= 0
      && windowPos.r < this.rowCount;
  }

  update() {
    if(this.changed) {
      refresh();
    } else if(this.cellsChanged.length > 0) {
      if(drawCell == null || clearCell == null) {
        refresh();
      } else {
        this.cellsChanged.forEach(pos => {
          clearCell(pos);
          drawCell(pos);
        });
        this.cellsChanged = [];
      }
    } 
  }

  refresh() {
    clear();
    draw();
  }
}

class LevelWindow extends Window {

  constructor(screen) {
    super("Level", screen, Math.floor(screen.columnCount * 2 / 3), screen.rowCount - 4);
    this.scrollMargin = 4;
    this.panC = 0;
    this.panR = 0;
    this.trackPlayer = true;
  }

  adjustPan() {
    if(targetC < windowC + shared.scrollMargin && windowC > 0) {
      windowC = Math.max(0, targetC - shared.scrollMargin);
      this.changed = true;
    } 

    if(targetR < windowR + shared.scrollMargin && windowR > 0) {
      windowR = Math.max(0, targetR - shared.scrollMargin);
      this.changed = true;
    } 

    if(targetC > windowC + windowWidth - shared.scrollMargin && windowC + windowWidth < levelWidth) {
      windowC = Math.min(levelWidth - windowWidth, targetC + shared.scrollMargin - windowWidth);
      this.changed = true;
    } 

    if(targetR > windowR + windowHeight - shared.scrollMargin && windowR + windowHeight < levelHeight) {
      windowR = Math.min(levelHeight - windowHeight, targetR + shared.scrollMargin - windowHeight);
      this.changed = true;
    }
  }

  draw() {
    if(this.trackPlayer) {
      adjustPan();
    }

    for(let c = 0; c < this.columnCount; c++) {
      for(let r = 0; r < this.rowCount; r++) {
        drawCell({c: c, r: r});
      }
    }

    this.changed = false;
  }

  drawCell(windowPos) {
    if(windowPos.c == null || windowPos.r == null) {
      throw new Error("Invalid windowPos: " + windowPos);
    }

    if(!isPosValid(windowPos)) {
      throw new Error("Invalid windowPos: " + windowPos);
    }

    var levelPos = windowToLevelPos(windowPos);
    var cell = game.level[levelPos.c][levelPos.r];
    var characterToDraw;
    if(cell.occupiedBy != null) {
      characterToDraw = cell.occupiedBy.showAs;
    } else if(cell.onFloor != null) {
      characterToDraw = cell.onFloor[0].showAs;
    } else {
      characterToDraw = cell.floorType.showAs;
    }

    drawText(windowPos.c, windowPos.r, characterToDraw, cellWidth);
  }

  levelToWindowPos(levelPos) {
    if(!game.isLevelPosValid(levelPos)) {
      throw new Error("Invalid board pos: " + levelPos);
    }

    var windowPos = { c: levelPos.c - this.panC, r: levelPos.r - this.panR };

    return windowPos;
  }

  windowToLevelPos(windowPos) {
    if(!isPosValid(windowPos)) {
      throw new Error("Invalid window pos: " + windowPos);
    }

    var levelPos = { c: windowPos.c + this.panC, r: windowPos.r + this.panR };

    if(!isLevelPosValid(levelPos)) {
      throw new Error("Invalid board pos: " + levelPos);
    }

    return levelPos;
  }

}

class StatusWindow extends Window {

  constructor(screen) {
    super("Status", screen, Math.floor(screen.columnCount * 1 / 3), 2);
    this.screen = screen;
  }

  draw() {
    drawText(0, 0, "Action: " + this.screen.currentAction);
    drawText(0, 1, "HP: " + game.player.health);
    this.changed = false;
  }

}

class MessageWindow extends Window {
  constructor(screen) {
    super("Message", screen, screen.columnCount, 4);
    this.messages = [];
  }

  addMessage(message) {
    this.messages.push(message);
    this.changed = true;
  }

  clearMessages() {
    this.messages = [];
    this.changed = true;
  }

  draw() {
    for(let r = 0; r < messsages.length; r++) {
      let message = messages[r];
      drawText(0, r, message);
    }
    this.changed = false;
  }
}

class Screen {
  constructor(name, initialKeyListener) {
    this.initialKeyListener = initialKeyListener;
    this.name = name;
    //this.windows = {};
  }

  update() {
    for(const w in this.windows) {
      this.windows[w].update();
    }
  }

  refresh() {
    for(const w in this.windows) {
      this.windows[w].refresh();
    }
  }

  positionWindows() {
    let firstRow = 0;
    let firstCol = 0;
    let secondRow = 0;

    for(const w in this.windows) {
      let window = this.windows[w];
      if(this.columnCount - firstCol >= window.columnCount) {
        window.columnStart = firstCol;
        window.rowStart = firstRow;
        firstCol += window.columnCount;
        secondRow = Math.max(secondRow, window.rowCount);
      } else {
        window.columnStart = 0;
        window.rowStart = secondRow;
        firstRow = secondRow;
        firstCol = window.columnCount;
        secondRow = window.rowCount;
      }
    };
  }

}

class MainScreen extends Screen {

  constructor() {
    super("Main");

    this.cellWidth = 26;
    this.cellHeight = 30;
    this.columnCount = Math.floor(canvasProps.width / this.cellWidth);
    this.rowCount = Math.floor(canvasProps.height / this.cellHeight);

    this.windows = {
      level: new LevelWindow(this.columnCount, this.rowCount),
      status: new StatusWindow(this),
      message: new MessageWindow(this.columnCount, this.rowCount),
    };

    this.positionWindows();
    this.currentAction = this.motionActions.attackOrMove;
  }

  motionActions = {
    move: {
      display: "Move",
      execute: game.playerMove
    },
    attack: {
      display: "Attack",
      execute: game.playerAttack
    },
    attackOrMove: {
      display: "Attack or Move",
      execute: game.playerAttackOrMove
    }
  };

  keyHandler(e) {
    this.clearMessages();

    if(e.key == "h" || e.key == "ArrowLeft") {
      currentAction.execute(-1, 0);
    }
    else if(e.key == "l" || e.key == "ArrowRight") {
      currentAction.execute(1, 0);
    }
    else if(e.key == "j" || e.key == "ArrowDown") {
      currentAction.execute(0, 1);
    }
    else if(e.key == "k" || e.key == "ArrowUp") {
      currentAction.execute(0, -1);
    }
    else if(e.key == "y") {
      currentAction.execute(-1, -1);
    }
    else if(e.key == "u") {
      currentAction.execute(1, -1);
    }
    else if(e.key == "b") {
      currentAction.execute(-1, 1);
    }
    else if(e.key == "n") {
      currentAction.execute(1, 1);
    }
    else if(e.key == ".") {
      advanceTime();
    }
    else if(e.key == "A") {
      currentAction = this.motionActions.attackOrMove;
      updateStatus();
    }
    else if(e.key == "a") {
      currentAction = this.motionActions.attack;
      updateStatus();
    }
    else if(e.key == "m") {
      currentAction = this.motionActions.move;
      updateStatus();
    }
    else if(e.key == "?") {
      face.toFrontHelp();
    }
    else if(e.key == "R") {
      face.addMessage("Are you sure you want to restart this game?");
      face.addMessage("All progress will be lost. (y/n)");
      setKeyListener(confirmHandler, restart, face.toFrontMain);
    }

    face.update();
  }
}

class HelpScreen extends Screen {
  constructor() {
    super("Help");

    this.windows = {
      commandList: new CommandListWindow(this.columnCount, this.rowCount),
      commandDetail: new CommandDetailWindow(this.columnCount, this.rowCount),
    };

    this.positionWindows();
  }

  keyHandler(e) {
    if(e.key == "j" || e.key == "ArrowDown") {
      if(helpCursor < helpCount - 1) {
        helpCursor++;
      }
    }
    else if(e.key == "k" || e.key == "ArrowUp") {
      if(helpCursor > 0) {
        helpCursor--;
      }
    }
    else if(e.code == "Escape") {
      face.toFrontMain();
    }

    face.update();
  }
  

}

class CommandListWindow extends Window {
  constructor(screenColumnCount, screenRowCount) {
    super(screenColumnCount, screenRowCount - 3);
    this.helpCursor = 0;
  }

  draw() {
    var helpBook = helpItems[currentWindowMode];
    const keyC = 0;
    const nameC = keyC + 3;
    const briefC = nameC + 9;
    for(var i = 0; i < helpBook.length; i++) {
      if(i == helpCursor) {
        ctx.fillRect(0, toY(i), canvas.width, cellHeight);
        ctx.filter = 'invert(1)';
      } else {
        ctx.filter = 'none';
      }
      drawText(keyC, i, helpBook[i].key);
      drawText(nameC, i, helpBook[i].name, 0, fontStyles.compact);
      drawText(briefC, i, helpBook[i].brief, 0, fontStyles.compact);
    }
  }

}

class CommandDetailWindow extends Window {
  constructor(screenColumnCount, screenRowCount) {
    super(screenColumnCount, 3);
  }

  drawHelpDetail() {
    var detail = helpBook[helpCursor].detail;
    if(detail != null) {
      drawText(0, 0, detail, 0, fontStyles.compact);
    } else {
      drawText(0, 0, "No further information is available.", 0, fontStyles.compact);
    }
  }

}

class Face {

  constructor() {
    this.screens = {
      main: new MainScreen(),
      help: new HelpScreen()
    };

    this.currentKeyListener = null;
    this.currentScreen = null;
    this.toFrontMain();
  }

  addMessage(message) {
    this.screens.main.windows.message.addMessage(message);
  }

  clearMessages() {
    this.screens.main.windows.message.clearMessages();
  }

  clear() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }

  toFrontMain() {
    this.toFront(this.screens.main);
  }

  toFrontHelp() {
    this.toFront(this.screens.help);
  }

  toFront(screen) {
    // not using yet
    //document.addEventListener("keydown", keyDownHandler, false);

    if(this.currentKeyListener != null) {
      document.removeEventListener("keyup", currentKeyListener, false);
    }

    this.currentKeyListener = screen.keyHandler;
    document.addEventListener("keyup", this.currentKeyListener, false);
    this.currentScreen = screen;
  }

  update() {
    this.currentScreen.update();
  }

  refresh() {
    this.currentScreen.refresh();
  }
}

const ai = {
  simplePursuit: function(actor) {
    var adjacent = adjacentCells(actor.pos);
    for(var i = 0; i < adjacent.length; i++) {
      var pos = adjacent[i];
      var cell = getCell(pos);
      if(cell.occupiedBy == player) {
        game.executeAttack(actor, player);
        return;
      }
    }

    if(random(3) == 0) {
      var pos = adjacent[random(adjacent.length)];
      var cell = getCell(pos);
      if(cell.occupiedBy == null) {
        game.executeMove(actor, pos);
      }
    }
  }
};

// These should never be altered. They are used to create other objects which may be altered.
const objects = {
  dirtFloor: { showAs: '.' },
  rockWall: { showAs: '🀆' },
};

// These should never be altered. They are used to create other objects which may be altered.
const creatures = {
  player: { name: 'player', showAs: '🙂', health: 10, attack: { min: 0, max: 2 }, pos: { c: 0, r: 0 } },
  newt:   { name: 'rat',    showAs: '🐭', health: 2,  attack: { min: 0, max: 1 }, act: ai.simplePursuit, pos: { c: 0, r: 0 } },
  lion:   { name: 'lion',   showAs: '🦁', health: 10, attack: { min: 0, max: 4 }, act: ai.simplePursuit, pos: { c: 0, r: 0 } },
};

class Game {

  calculateDamageFrom(attacker) {
    let minDamage = 0;
    let maxDamage = 0;
    if(attacker.attack != null) {
      minDamage = attacker.attack.min;
      maxDamage = attacker.attack.max;
    }

    return Math.floor(Math.random() * (1 + maxDamage - minDamage)) + minDamage;
  }

  isLevelPosValid(levelPos) {
    return levelPos.c >= 0
      && levelPos.c < this.levelWidth
      && levelPos.r >= 0
      && levelPos.r < this.levelHeight;
  }

  setCellOccupiedBy(c, r, occupant) {
    this.level[c][r].occupiedBy = occupant;
    if(occupant != null) {
      occupant.pos.c = c;
      occupant.pos.r = r;
    }
  }

  constructor() {
    this.levelWidth = 30;
    this.levelHeight = 30;
    this.level = [];

    for(var c = 0; c < this.levelWidth; c++) {
      this.level[c] = [];
      for(var r = 0; r < this.levelHeight; r++) {
        if(c == 0 || r == 0 || c == this.levelWidth - 1 || r == this.levelHeight - 1) {
          this.level[c][r] = { occupiedBy: objects.rockWall, onFloor: null, levelType: objects.dirtFloor }
        } else {
          this.level[c][r] = { occupiedBy: null, onFloor: null, levelType: objects.dirtFloor }
        }
      }
    }

    this.actors = [];

    this.player = _.cloneDeep(creatures.player);
    this.setCellOccupiedBy(5, 5, this.player);
    this.addActor(2, 2, creatures.newt);
    this.addActor(7, 7, creatures.newt);
    this.addActor(10, 10, creatures.lion);
  }

  addActor(c, r, actor) {
    actor = _.cloneDeep(actor);
    this.actors.push(actor);
    this.setCellOccupiedBy(c, r, actor);
  }

  adjacentCells(subjectPos) {
    var result = [];
    for(var c = subjectPos.c - 1; c <= subjectPos.c + 1; c++) {
      if(c < 0 || c > this.levelWidth) continue;
      for(var r = subjectPos.r - 1; r <= subjectPos.r + 1; r++) {
        if(r < 0 || r > this.levelHeight) continue;
        if(c == subjectPos.c && r == subjectPos.r) continue;
        result.push({ c: c, r: r });
      }
    }

    return result;
  }

  executeMove(actor, pos) {
    setCellOccupiedBy(actor.pos.c, actor.pos.r, null);
    setCellOccupiedBy(pos.c, pos.r, actor);
  }

  executeAttack(source, target) {
    damage = calculateDamageFrom(source);
    target.health -= damage;

    var message;
    if(damage > 0) {
      message = "The " + source.name + " hit you for " + damage + " damage.";
      face.addMessage(message);
      updateStatus();
      if(target.health <= 0) {
        if(target == player) {
          face.addMessage("You died. Press 'R' to restart.");
          setKeyListener(rKeyHandler, restart);
        }
      }
    } else {
      message = "The " + source.name + " missed you.";
      face.addMessage(message);
    }
  }

  advanceTime() {
    this.actors.forEach(actor => {
      actor.act(actor);
    });
  }

  playerMove(targetC, targetR) {
    targetC += this.player.pos.c;
    targetR += this.player.pos.r;

    let targetCell = this.level[targetC][targetR];
    if(targetCell.occupiedBy != null) {
      face.addMessage("That space is already occupied.");
      return;
    }

    setCellOccupiedBy(player.pos.c, player.pos.r, null);
    setCellOccupiedBy(targetC, targetR, player);
    advanceTime();
  }

  playerAttack(targetC, targetR) {
    targetC += player.pos.c;
    targetR += player.pos.r;

    var targetCell = level[targetC][targetR]
    if(targetCell.occupiedBy == null) {
      face.addMessage("There is nothing there to attack.");
      return;
    }

    var target = targetCell.occupiedBy
    if(target.health == null) {
      face.addMessage("You can't attack that.");
      return;
    }

    var damage = calculateDamageFrom(player);
    target.health -= damage;
    var message = "You hit the " + target.name + " for " + damage + " damage.";
    if(damage > 0) {
      message = "You hit the " + target.name + " for " + damage + " damage.";
    } else {
      message = "You miss the " + target.name + ".";
    }

    if(target.health <= 0) {
      message += " The " + target.name + " is dead."; 
      targetCell.occupiedBy = null;
      this.actors = this.actors.filter(function(a) { return a != target; });
      screens.main.windows.level.cellsChanged.push({c: targetC, r: targetR});
    } else {
      if(damage > 0) {
        message += " hp=" + target.health;
      }
    }
    face.addMessage(message);

    advanceTime();
  }

}

var face;
var game;

var helpItems = {
  main: [
    { key: "hjkl",
      name: "Orthagonal Motion",
      brief: "Move / Attack left, down, up, right. You can also use the arrow keys.",
      detail: "If you are in movement mode, pressing these keys move the player around the dungeon. In attack mode, this will attempt to attack an adjacent creature / object."
    },
    { key: "yubn",
      name: "Diagonal Motion",
      brief: "Move / Attack up-left, up-right, down-left, down-right",
      detail: "If you are in movement mode, pressing these keys move the player around the dungeon. In attack mode, this will attempt to attack an adjacent creature / object."
    },
    { key: "a",
      name: "Attack Mode",
      brief: "While in Attack Mode, motion keys will not move the player, but instead attack in the given direction.",
      detail: null
    },
    { key: "m",
      name: "Move Mode",
      brief: "While in Move Mode, motion keys will move the player, and never attack a creature.",
      detail: null
    },
    { key: "A",
      name: "Move or Attack Mode",
      brief: "While in Move or Attack Mode, motion keys will move the player if the space is empty, otherwise the player will attack in the given direction.",
      detail: null
    },
    { key: ".",
      name: "Wait",
      brief: "Allow time to pass, and enemies to act.",
      detail: null
    },
    { key: "?",
      name: "Help",
      brief: "This help page",
      detail: null
    },
    { key: "R",
      name: "Restart Game",
      brief: "Loses all current progress, and starts the game over fresh.",
      detail: null
    },
  ]
};

function restart() {
  game = new Game();
  face = new Face();
  face.update();
}

function random(possibilities) {
  return Math.floor(Math.random() * possibilities);
}

function log(message) {
  console.log(message);
}

function playerAttackOrMove(targetC, targetR) {
  var targetCell = level[targetC + player.pos.c][targetR + player.pos.r]
  if(targetCell.occupiedBy != null) {
    playerAttack(targetC, targetR);
  } else {
    playerMove(targetC, targetR);
  }
}

function keyDownHandler(e) {
}

function anyKeyHandler(e) {
  clearMessages();
  if(handlerOkResponse != null) {
    handlerOkResponse();
  }
}

function rKeyHandler(e) {
  if(e.key == "R") {
    if(handlerOkResponse != null) {
      handlerOkResponse();
    }
  }
}

function confirmHandler(e) {
  if(e.key == "y") {
    if(handlerOkResponse != null) {
      handlerOkResponse();
    }
  } else if(e.key == "n") {
    if(handlerCancelResponse != null) {
      handlerCancelResponse();
    }
  }
}


function refreshCell(levelPos) {
  var windowPos = levelToWindowPos(levelPos);
  if(!isWindowPosValid(windowPos)) {
    return;
  }
  clearCell(windowPos);
  drawCell(windowPos);
}

restart();

</script>

</body>
</html>
